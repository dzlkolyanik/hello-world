#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstring>

#pragma warning(disable : 4996)
using namespace std;

void myins(char *s, int n_start, char *t)
{
	char *p = s + n_start, *q = s + strlen(s);
	int n = strlen(t);
	while (q >= p) {
		*(q + n) = *q;
		q--;
	}
	strncpy(p, t, n);
}

int consolen = 70;

int main()
{
	SetConsoleOutputCP(1251); SetConsoleCP(1251); srand(GetTickCount());

const int lens = 2048;
char *s0 = new char[lens];

{	cout << "=== Задание 1 =================\n";

strcpy(s0, "	Происхождение слова «баг»\n\
	В феврале 1944 года ученый Гарвардского университета Говард Айкен\n\
(1900..1973) и команда помощников из компании IBM построили вычислительное\n\
устройство, которое они назвали Harvard Mark I.Эта машина стала первым ши - \n\
роко известным программируемым релейно - механическим цифровым калькулятором.\n\
	Машина была длиною около 17 метров, весила 5 тонн и состояла из 500 000\n\
частей.Числа обрабатывались с фиксированной точкой, положение которой\n\
определялось с помощью специального переключателя.Операция сложения зани -\n\
мала треть секунды, умножение – приблизительно 1 секунду.\n\
	В июле 1947 года Говард Айкен и его команда завершили постройку\n\
Harvard Mark II, большого вычислительного устройства, использовавшего реле\n\
как для реализации 50 регистров с плавающей точкой, так и для арифметиче -\n\
ского устройства.\n\
	Через два месяца таракан(? ..1947), забравшись в Harvard Mark II, при -\n\
вел к ошибкам при проведении операций с плавающей точкой.Обнаруживший его\n\
техник сделал следующую запись в лабораторном журнале :\n\
	«Сегодня обнаружен первый настоящий баг»(Bug – жук, насекомое, англ.).\n\
	К этой записи он приложил все бережно собранные останки насекомого.\n\
С этого момента слово «баг» приобрело еще одно значение и стало использовать -\n\
ся программистами всего мира в переносном смысле – ошибка в программе.\n");
cout << "Исходный текст:\n" << s0 << endl;
const int  ns = 20;
char*s[ns],*p=s0,*q=s0;
char s1[] = "432glanskdj122psdjflfk";
char num[] =  "1234567890" ;



for (int i = 0; i < ns; i++)
{
	p = strchr(q, '\n');
	s[i] = new char[p - q + 1];
	strncpy(s[i], q, p - q);
	s[i][p - q] = 0;
	q = p + 1;
}
int k=0,max=0,z=0,zmax=0;
char *a = s0,*b=s0;

//cout << s[5] << endl;
//cout << strspn(s1, num);
a = s[5];
/*while (*a)
{

	a += strcspn(a, num);


	//cout <<endl <<a<<endl;
	k += strspn(a, num);
	a += strspn(a, num);


}*/
//cout << endl << s[5] << "  kol-vo  " << k << endl;

for (int i = 0; i < ns; i++)
{
	a = s[i];
	k = 0;
	while(*a)
	{
		
		a+= strcspn(a, num);
		

		//cout <<endl <<a<<endl;
		k += strspn(a, num);
		a+= strspn(a, num);
		
		
	}
	//cout << endl << s[i] << "  kol-vo  " <<k<<endl;
	if (k > max)
	{
		max = k;
		z = i;
	}
}
cout << "\nМаксимальное количество цифр  (" << max << ") ";
cout << "в строке :  \n" << s[z] << endl;
//delete[]s;
//delete[] s0;
/*for (int i = 0; i < ns; i++)
{
	delete[]s[i];
}*/
}


{
	cout << "\n=== Задание 2 =================\n";
	strcpy(s0, "\
			Происхождение      слова  «хакер»\n\
	В последние  годы английское слово   «хакер» прочно вошло   в русский и\n\
многие другие   языки . И теперь мало кто  помнит, что первоначально   это слово\n\
вовсе не   носило негативного  оттенка , а первые   хакеры шутили вполне безобидно.\n\
	Каждый  год в ночь накануне   Дня дурака купол главного   здания Массачу- \n\
сетского   технологического   института украшается   каким-нибудь  неожиданным и \n\
весьма   громоздким предметом .   Это традиционная забава  выпускников. До сих\n\
пор   осталось тайной, как  туда затащили полицейский   автомобиль ,   – снимать\n\
его  пришлось вертолетом. Вывешивали   тут и гигантские флаги ,   и еще Бог знает\n\
что.  Как-то на вершину   купола втянули  даже рояль .\n\
	Такие шутки   назвали «хаками» , от них же пошло и  «хакер», т .е . «делающий\n\
хаки».   Хакер в подлинном смысле – это  компьютерный интеллигент, тот,   кто не\n\
отдал себя  полностью бизнесу , кто  стремится сохранить  самобытность своего «Я»,\n\
– разумеется, при  этом он просто обязан   быть специалистом.\n\
	Американское  «hack» имеет десятки  значений – мотыга ,   кляча, но также и\n\
«изысканная   проделка интеллектуалов» . Авторы   проделки должны  остаться неиз- \n\
вестными,  во всяком случае на   время . Хак должен  поразить окружающих, не\n\
причинив при   этом – что принципиально  важно – ни им, ни   окружающей среде ни\n\
малейшего  вреда . Именно поэтому   рояль на куполе  университета не был признан\n\
хаком, –   затаскивая его на  крышу , студенты   повредили штукатурку.\n");

	cout << "Исходный текст:\n" << s0 << endl;

	const int  ns = 20;
	char*s[ns], *p = s0, *q = s0;

	for (int i = 0; i < ns; i++)
	{
		p = strchr(q, '\n');
		s[i] = new char[p - q + 1];
		strncpy(s[i], q, p - q);
		s[i][p - q] = 0;
		q = p + 1;
	}
	char *b = s0, *a, alf[1000], *p1, *q1;
	int n = 0;
	for (int i = 0; i < ns; i++)
	{
	a = s[i];
	n = 0;
	b = s[i] + strlen(s[i]) - 1;
	//strcpy(alf, s[i]);
	p = s[i];
	q = s[i];
	while (*a)
	{

		if (*a == ' ' || *a == '\t')
		{
			a++;
			n++;
		}
		else
		{
			p = a;
			break;
		}
	}

	int k = 0;

	while (*b)
	{
		if (*b == ' ' || *b == '\t')
		{
			b--;
			k++;
		}
		else
		{
			q = b;
			break;
		}
	}

	n = 0;
	//cout << *p << "    " << *q << endl;

	for (; p < q;)
	{
		if (*p == ' ' && *(p + 1) == ' ')
		{
			for (char *d = p; d < q; d++)
				*d = *(d + 1);

			*q = ' ';
			q--;
		}

		else
		{

			if (*p == ' ' && *(p + 1) == ',')
			{
				for (char *d = p; d < q; d++)
					*d = *(d + 1);

				*q = ' ';
				q--;
			}
			else
			{

				if (*p == ' ' && *(p + 1) == '.')
				{
					for (char *d = p; d < q; d++)
						*d = *(d + 1);

					*q = ' ';
					q--;
				}
				else
					p++;
			}
		}

	}


	/*	cout << endl << s[i] << endl;
		cout <<" strnum "<<i<< "  frstlet  " << *p ;
		cout  << " posllet  " << *q << endl;*/


	}


	cout << "\nИзменённый текст:\n";
	for (int i = 0; i < ns; i++)
	{
		cout << s[i] << endl;

	}
	//delete[]s;
	//delete[] s0;
	/*for (int i = 0; i < ns; i++)
	{
	delete[]s[i];
	}*/
}


{
	cout << "\n=== Задание 3 =================\n";

	/*char pr[1000] = "Abass", *w1, pr2[] = "Wow", *w2;
	w1 = pr;
	w2 = pr + 2;
	myins(w1, 1, pr2);
	cout << w1;*/
	


	//start



	const int  ns = 9;
	char*s[ns], *p = s0, *q = s0;
	int lol, lenmax = 0;

	strcpy(s0, "\
    Начнем с определения терминов класса и объекта. Класс определяет новый \n\
тип данных,который задает формат объекта. Класс включает как данные, так и \n\
код, предназначенный для выполнения над этими данными.Следовательно, \n\
класс связывает данные с кодом.В C++ спецификация класса используется для \n\
построения объектов. Объекты - это экземпляры класса.По сути, класс \n\
представляет собой набор планов , которые определяют, как строить объект. \n\
Важно понимать, что класс - это логическая абстракция, которая реально не \n\
существует до тех пор, пока не будет создан объект этого класса, т.е.то, \n\
что станет физическим представлением этого класса в памяти компьютера . \n");
	cout << "Исходный текст:\n" << s0 << endl;

	char *b , *a;
	int n,k;
	for (int i = 0; i < ns; i++)
	{
		p = strchr(q, '\n');
		lol = p - q;
		if (lol > lenmax)
			lenmax = lol;

		s[i] = new char[p - q + 1];
		strncpy(s[i], q, p - q);
		s[i][p - q] = 0;
		q = p + 1;
		//cout << " $ " << i << s[i] << "  Kol-vo simvolov = " << lol<<" or "<<strlen(s[i])<<endl;
	}
	//cout << lenmax << endl;
	
	for (int i = 0; i < ns-1; )
	{
		if (strlen(s[i]) == lenmax)
			i++;
		else
		{
			
			a = s[i];
			n = 0;
			b = s[i] + strlen(s[i]) - 1;
			//strcpy(alf, s[i]);
			p = s[i];
			q = s[i];
			while (*a)
			{

				if (*a == ' ' || *a == '\t')
				{
					a++;
					n++;
				}
				else
				{
					p = a;
					break;
				}
			}
			k = 0;
			while (*b)
			{
				if (*b == ' ' || *b == '\t')
				{
					b--;
					k++;
				}
				else
				{
					q = b;
					break;
				}
			}//while b

			//cout <<*p<< "   " << *q << endl;
			a = p;
			b = strchr(p, ' ');
			while (p < q)
			{
				if (strlen(p) < lenmax)
				{
					myins(p, b - p, " ");
					b += 2;
					a = b;
					b = strchr(a, ' ');
					q--;
				}
				else
					break;
			}

			i++;
		}//else
	}//1for
	cout << "Выровненный текст:\n";
	for (int i = 0; i < ns; i++)
	{
		cout << s[i] << endl;
	}


	//delete[]s;
	/*for (int i = 0; i < ns; i++)
	{
	delete[]s[i];
	}*/
}






{



cout << "\n=== Задание 4 =================\n";




const int  ns = 9;
char*s[ns], *p = s0, *q = s0;

strcpy(s0, "\
Начнем с определения терминов класса и объекта. Класс определяет новый \n\
тип данных,который задает формат объекта. Класс включает как данные, так и \n\
код, предназначенный для выполнения над этими данными.Следовательно, \n\
класс связывает данные с кодом.В C++ спецификация класса используется для \n\
построения объектов. Объекты - это экземпляры класса.По сути, класс \n\
представляет собой набор планов , которые определяют, как строить объект. \n\
Важно понимать, что класс - это логическая абстракция, которая реально не \n\
существует до тех пор, пока не будет создан объект этого класса, т.е.то, \n\
что станет физическим представлением этого класса в памяти компьютера . \n");
//cout << "Исходный текст\n" << s0 << endl;
int sum=0;
for (int i = 0; i < ns; i++)
{
	p = strchr(q, '\n');
	s[i] = new char[p - q + 1];
	strncpy(s[i], q, p - q);
	s[i][p - q] = 0;
	q = p + 1;
}

int n = 0;
char *a = s0;
char sep[] = "\t -.,:;?!+-()\n\13\10\9\'\.,;: /""";
char glas[] = "ёуеыаоэяию";
char *w;
const int nw = 10000;
p = s0;
char **words = new char*[nw];

char *g1, *g2;
int *A = new int [nw],k=0;
a += strspn(a, sep);
	for (int i=0; ;i++, n++)
	{
		
		words[i] = new char[a - p];
		 strncpy(words[i],p,a - p);
		 words[i][a - p] = 0;
		 a += strspn(a, sep);
		 p = a ;
		if (!*a) break;
		int	len = strcspn(a, sep);
		a += len;
		
		g1 = words[i];
		while(*g1)
		{
			if (strspn(g1, glas) ) {
				
				k+= strspn(g1, glas);
					g1+= strspn(g1, glas);
			}
			
			g1 += strcspn(g1, glas);
		}
		A[i] = k;
		//cout << words[i] <<" Kol-vo glasn = "<<A[i]<< endl;
		k = 0;
	}

	int m = n;
	do {
		k = 0; m--;
		for (int i = 0; i < m; i++) {
			if (A[i] > A[i + 1]) {
				A[i + 1] += A[i];
				A[i] = A[i + 1] - A[i];
				A[i + 1] -= A[i];
				k = 1;
				char*t;
				t = words[i];
				words[i] = words[i + 1];
				words[i + 1] = t;
			}
		}
	} while (k);
	k = 0;
	for (int i = 0; i < 7; i++)
	{
		cout << "\n\nКоличество гласных букв " << i << " : \n";
		k = 0;
		sum = 1;
		for (int j = 0; j < n; j++)
		{
			if (A[j] == i) {
				sum += strlen(words[j])+1;
				if (sum > consolen)
				{
					cout << endl;
					sum = 1;
				}
				cout  << words[j] << "  ";
				/*k++;
				if (k % 7 == 0)
					cout << endl;*/
			}
			
			
		}



		//delete[] s0;
		//delete[] words[i];
		/*for (int i = 0; i < 94; i++)
		{
		delete[]words[i];
		}*/
	}
//	printf("Количество слов втексте = %d\n", n);
	

		



}

{
			cout << "\n=== Задание 5 =================\n";

			//mylist#2  _23  MN-63  aBc_12  11z  я17
			const int n = 10,z=6;
			char s[z][n] = { { "mylist#2"},{"_23"} ,{"MN-63"}, {"aBc_12"}, {"11z"},{"я17" } },*a;
			char neg[] = {"1234567890~!@#$%^&*()+`}{?.,ёЁйцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,=-"};
			char neg2[] = {"~!@#$%^&*()+=-ёЁйцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ"};
			//cout << s[0][0]<<endl;
			int flag=0;
		//	cout << endl << endl;
			for (int i = 0; i < z; )
			{
				//cout << s[i]<<" - ";
				a = s[i];
				flag = 0;
				if (strchr(neg, s[i][0]) != NULL)
				{
					i++;
					flag = 1;
				}
				
				else
				{
					for (int j = 0; j < n; j++)
					{
						if (strchr(neg2, s[i][j]) != NULL && s[i][j]!='\0')
						{
							flag = 1;
							break;
						}
						else
						{
							flag = 0;
						}

					}
					
					i++;
				}
				if (flag)
					printf("%-10s - недопустимый идентификатор\n", a);
				else
					printf("%-10s - Ok\n", a);
			
				
			}
			
}


{	

		cout << "\n=== Задание 6 =================\n";
 strcpy(s0, "\
template<class T>\n\
class Stack\n\
{\n\
public:\n\
	Stack(size_t size = 0)\n\
		: impl_(size) {}\n\
	Stack(const Stack& other)\n\
		: impl_(other.impl_.vused_) {\n\
		while(impl_.vused_ < other.impl_.vused_) {\n\
			construct(impl_.v_ + impl_.vused_,\n\
			other.impl_.v_[impl_.vused_]);\n\
			++impl_.vused_; }\n\
	}\n\
	Stack& operator=(const Stack& other) {\n\
		Stack temp(other);\n\
		impl_.Swap(temp.impl_); /* Здесь исключений нет {{{ */\n\
		return *this;\n\
	}\n\
	size_t Count() const {\n\
		return impl_.vused_;\n\
	}\n\
	void   Push(const T& t) {\n\
		if (impl_.vused_ == impl_.vsize_) {\n\
			Stack temp(impl_.vsize_*2 + 1);\n\
			while(temp.Count() < impl_.vused_) {\n\
				temp.Push(impl_.v_[temp.Count()]); }\n\
			temp.Push(t);\n\
			impl_.Swap(temp.impl_); }\n\
		else {\n\
			construct(impl_.v_ + impl_.vused_, t);\n\
			++impl_.vused_; }\n\
	}\n\
	T& Top() {\n\
		if (impl_.vused_ == 0) {\n\
			throw \"empty stack\"; }\n\
		return impl_.v_[impl_.vused_ - 1];\n\
	}\n\
	void Pop() {\n\
		if (impl_.vused_ == 0) {\n\
			throw \"pop from empty stack\"; }\n\
		else {\n\
			--impl_.vused_; destroy(impl_.v_ + impl_.vused_); }\n\
	}\n\
private:\n\
StackImpl<T> impl_; // Сокрытие реализации {{{ \n\
	};\n");
 cout << s0<<endl;

 int ncol = 0, nrow = 0,balance=0,ncomm=0,k=0,n=0;

 //cout << endl << '*'<<endl;

 while (*s0)
 {
	
	/* if (*s0 == '/' && *(s0 + 1) == '/')
		 ncomm = 1;
	 else
	 {
		 if(*s0 == '/' && *(s0 + 1) == '*')
			 ncomm = -1;
		 else
			 ncomm = 0;
	 }*/

	 if (*s0 == '{' && ncomm == 0)
	 {
		 balance++;
		
	 }
	 if (balance == 1)
	 {
		 ncol = k;
		 nrow = n;
	 }

	 if (*s0 == '}' && ncomm == 0)
	 {
		 balance--;
		
	 }
	 if (balance < 0)
	 {
		 ncol = k;
		 nrow = n;
		 break;
	 }
	 if (*s0 == '/' && ncomm == 0)
	 {
		 if (*(s0 + 1) == '/')
		 {
			 ncomm = 1;
		 }
		 else
		 {
			 if(*(s0 + 1) == '*')
				 ncomm = -1;
		 }
	 }
	 if (*s0 == '*' && ncomm == -1)
	 {
		 if (*(s0 + 1) == '/')
			 ncomm = 0;
	 }
	 if (*s0 == '\n')
	 {
		 if (ncomm == 1)
			 ncomm = 0;
		 n++;
		 k = 0;
	 }
	 k++;
	 s0++;
 }

 if (balance == 0)
	 cout << "\nфигурные скобки расставлены расставлены правильно\n";
 else
	 cout <<balance<< " \nфигурные скобки расставлены неправильно\n";


}


system("pause"); return 0;
}
